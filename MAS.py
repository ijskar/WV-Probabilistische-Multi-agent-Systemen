import random as rnd

from problog_controller import *
from matplotlib import colors
from matplotlib import pyplot as plt
import time


class Agent:
    """
    A class used to represent an agent within the multi-agent system.

    Attributes
    ----------
    number : int
        The unique identifier for this agent.
    plan : list
        The plan this agent wants to execute.
    """

    def __init__(self, number, plan):
        """
        The constructor of an Agent.
        :param number: The id of the agent.
        :param plan: The plan of the agent.
        """

        self.number = number
        self.plan = plan

class MAS:
    """
    A class used to represent a multi-agent system, which provides the functionalitie of executing the plans
    of every agent.

    Attributes
    ----------
    actionCaseList : list
        A list of all actionCases that define the actions that can be taken by agents. It defines
        the world for this multi-agent system
    failCondition : str
        The body of a failcondition predicate, provided in ProbLog code. Familiarity with ProbLog
        is required in order to use this parameter.
    queryLessProgramString : str
        A string representing a ProbLog program, generated by the actionesToProblogProgram method, which is able
        to reason about the action in the given plan.
    beginState : list
        A string representing a list of ProbLog facts, which describes the initial state of the world in the
        multi-agent system. For example: "[on(b,a),table(a),clear(b)]" represents the state in which
        block b is on block a, while block a rests on the table and nothing else is on top of block b.
    perStepSatisfies : str
        (optional) The body of a satisfies-predicate, provided in ProbLog code. Familiarity with ProbLog
        is required. In each step of the execution, a query is done which probes the probability
        of entering a state which satisfies the conditions specified in the body of the satisfies-predicate.
    visualizeState : function
        (optional) A function which generates a visual representation of a given state, specifically for the world
        of this multi-agent system.
    windowSize : integer
        (optional) An integer indicating how many of the following steps are taken into account when computing
        the probability of the satisfaction fo the satisfies-predicate.
    agentList : list
        (Optional) A list of strings containing the Agent-objects, representing the agents that are present in the world.

    Methods
    -------
    beginState()
        Returns the initial state of the multi-agent system
    beginState(beginState)
        Sets the intial state of the multi-agent system to the given state
    addAgent(number, plan)
        Adds an agent with its id and plan respectively set to the given number and plan.
    run()
        Runs the plans of all agents by switching between them after executing a single step of an agent's plan.
        Returns the endState, a list containing the chances on satisfying the satisfaction-predicate and the
        corresponding computation times for calculating the chances.
    myExec(state, actionString)
        Actually executes an action in the given state of the world, by picking one of the possible consequences
        of the action. Returns the resulting state.
    pickCase(stateDictionary)
        Picks one of the cases from the given dictionary, respecting their chance of occurrence.
    listOfStringsToStringOfList(plan)
        Converts the given plan, which is a list of strings, into a single string representing a list which contains all
        elements of the given list.
    intertwinePlans()
        Merges the plans of all agents that are present in the multi-agent system.
    """

    def __init__(self, actionCaseList, failCondition, beginState, perStepSatisfies = None, visualizeState = None, windowSize = None, agentList = []):
        """
        The constructor of a multi-agent system.
        :param actionCaseList: A list of all actionCases that define the actions that can be taken by agents.
        :param failCondition: The body of a failcondition predicate, provided in ProbLog code.
        :param beginState: A list of strings representing ProbLog facts, which describes the initial state of the world in the
        multi-agent system.
        :param perStepSatisfies: (optional) The body of a satisfies-predicate, provided in ProbLog code. Familiarity with ProbLog
        is required. In each step of the execution, a query is done which probes the probability
        of satisfaction of the satisfies predicate.
        :param visualizeState:(optional) A function which makes a visual representation of a given state, specifically for the world
        of this multi-agent system.
        :param windowSize: (optional) An integer indicating how many of the following steps are taken into account when computing
        the probability of the satisfaction fo the satisfies-predicate.
        :param agentList: (Optional) A list of strings containing the Agent-objects, representing the agents that are present in the world.
        """

        self.actionCaseList = actionCaseList
        self.agentList = agentList
        self.beginState = beginState
        self.failCondition = failCondition
        self.queryLessProgramString = actionsToProblogProgram(self.actionCaseList, self.failCondition)
        self.perStepSatisfies = perStepSatisfies
        self.visualizeState = visualizeState
        self.windowSize = windowSize

    @property
    def beginState(self):
        """
        A method that retrieves the initial state of the multi-agent system.

        Returns
        -------
        :return: A string representing a list containing all ProbLog facts which are true in the initial state.
        """

        return self.__beginState

    @beginState.setter
    def beginState(self, beginState):
        """
        Sets the initial state to the given state.

        If the given state is a list of strings, it is converted into a string representing this list before
        saving it as an attribute of the MAS.

        Parameters
        ----------
        :param beginState: Either a string of a list or a list of strings. In both cases it specifies the initial state
        of the MAS.
        """

        if (type(beginState) == list):
            self.__beginState = self.listOfStringsToStringOfList(beginState)
        else:
            self.__beginState = beginState

    def addAgent(self, number, plan):
        """
        Adds an agent to the MAS.

        Once the agent is added, its plan will also be executed when running the function run.

        Parameters
        ----------
        :param number: An integer which uniquely identifies the agent to be added.
        :param plan: A list of strings, each representing an action, which specifies the plan the agent will execute.
        """

        self.agentList.append(Agent(number, plan))

    def run(self):
        """
        This method executes the plans of all agents that are present in the MAS.

        In each step the method switches to another agent to execute the next action of that agent. This alternation
        assures a fair execution between the agents. If a visualizeState function is provided, it is called after each
        execution of an action. The method also keeps track of the probability of satisfying the satisfies-predicate,
        when provided, in each step along with which it measures the time needed to compute this probability. If a
        windowsize is imposed, the method only takes into account that number of consecutive steps when calculating the
        probabilities.

        Returns
        -------
        :return: The resulting state (a string of a list), a list with the consecutive probabilities and a list with
        the corresponding execution times.
        """

        self.plan = self.intertwinePlans()
        currentState = self.beginState

        listOfProbabilities = []
        listOfTimesNeeded = []
        while(len(self.plan) > 0):

            if(self.visualizeState != None):
                if(type(currentState) == list):
                    self.visualizeState(self.listOfStringsToStringOfList(currentState))
                else:
                    self.visualizeState(currentState)

            if (self.perStepSatisfies != None):
                if(self.windowSize == None):
                    t = time.time()
                    result = endStateSatisfiesQuery(self.queryLessProgramString, currentState, self.plan,
                                                    self.perStepSatisfies)
                    timeNeeded = time.time() - t
                    for key in result:
                        listOfProbabilities.append(result[key])
                        print("Chance that end state will satisfy the given condition: " + str(result[key]))
                    print("Time needed to calculate this probability: " + str(timeNeeded))
                    listOfTimesNeeded.append(timeNeeded)
                else:
                    t = time.time()
                    result = endStateSatisfiesQuery(self.queryLessProgramString, currentState,
                                                    self.plan[0:self.windowSize],
                                                    self.perStepSatisfies)
                    timeNeeded = time.time() - t
                    for key in result:
                        listOfProbabilities.append(result[key])
                        print("Chance the given condition will be satisfied in " + str(self.windowSize) + " steps: " + str(result[key]))
                    print("Time needed to calculate this probability: " + str(timeNeeded))
                    listOfTimesNeeded.append(timeNeeded)
            next = self.plan[0]
            currentState = self.myExec(currentState, next)
            self.plan.remove(self.plan[0])

        #Also show the end state.
        if (self.visualizeState != None):
            self.visualizeState(currentState)

        print("List of probabilities: " + str(listOfProbabilities))
        return (currentState, listOfProbabilities, listOfTimesNeeded)




        # while(len(self.plan) > 0):
        #     next = self.plan[0]
        #     actionName  = next.split("(")[0]
        #     actionCaseList = []
        #     for action in self.actionList:
        #         if (actionName == action.name):
        #             actionCaseList.append(action)
        #     currentState = self.exec(currentState, actionCaseList)
        #     self.plan.remove(self.plan[0])
        # return currentState

    def myExec(self, state, actionString):
        """
        This method actually executes the given action in the given state of the world.

        It does so by picking one of the possible consequences of the action and respecting the distribution of the
        chances of occurence.
        For example:
            Let the action of moving a block from another block to the table have 2 possible consequences.
            In the first case there is 25% chance that the block will not be moved. Therefore, there is 75% chance that
            the action succeeds with the block ending up on the table. Now there will be 25% chance for myExec to
            execute the action while picking the first case and 75% chance of picking the latter case.

        Parameters
        ----------
        :param state: A list of strings representing the state in which the execution is to be started.
        :param actionString: A string representing the action to be executed.

        Returns
        -------
        :return: A string representing the resulting state.
        """

        stateDictionary = execQuery(self.queryLessProgramString, state, [actionString])
        #Parsing
        pickedCase = self.pickCase(stateDictionary)
        temp1 = str(pickedCase).split("[")[-1]
        temp2 = temp1.split("]")[0]
        return "[" + temp2 + "]"


    def pickCase(self, stateDictionary):
        """
        Picks one of the cases contained in the given stateDictionary.

        The given dictionary contains entries of which the keys are possible states of the multi-agent system and their
        corresponding values are their chance of occurence. The method pickCase divides the interval [0,1] into smaller
        intervals whose sizes match the probabilities of occurence of the different states in the dictionary. The
        method randomly generates a double and, depending on the range this value lies within, picks the corresponding
        case.

        Parameters
        ----------
        :param stateDictionary: A dictionary that matches the different states of the MAS with their chance of occurence.

        Returns:
        --------
        :return: The picked state, which is a string of a list.
        """
        randomNumber = rnd.uniform(0, 1)
        counter = 0.0
        for key in stateDictionary:
            counter += stateDictionary[key]
            if (randomNumber <= counter):
                return key
        return None

    def listOfStringsToStringOfList(self, list):
        """
        Converts a list of strings into a string of a list which contains the same elements as the given list.

        An example:
            if list = ["a","b","c"]
            then listOfStringsToStringOfList(list) results in "[a,b,c]"

        Parameters
        ----------
        :param list: The list to be converted into a string.

        Returns
        -------
        :return: The resulting string representing the given list.
        """

        planString = "["
        for element in list:
            planString += element + ", "
        planString = planString.rstrip(", ") + "]"
        return planString

    def intertwinePlans(self):
        """
        A method which intertwines two plans.

        The method takes two plans, and forms a new plan, in which actions from the given plans alternate, starting with the first action of the first given plan.
        If one of the two plans is shorter than the other, the surplus actions of the longer plan are placed consecutively at the end of the new plan.

        For example:
        plan1 = [a, a, a]
        plan2 = [b, b, b, b, b]
        Resulting plan = [a, b, a, b, a, b, b, b]

        Parameters
        ----------
        :param plan1: A list of strings representing the first plan. This is a list of actions, for example: ["moveToTable(d,c)", "moveFromBlockOn(c, b, e)"].
        :param plan2: A list of strings representing the second plan. This is a list of actions, for example: ["moveToTable(d,c)", "moveFromBlockOn(c, b, e)"].

        Returns
        -------
        :return: A list of strings representing the resulting, intertwined plan. This is a list of actions, for example: ["moveToTable(d,c)", "moveFromBlockOn(c, b, e)"].s
        """

        maxPlanLength = 0
        for agent in self.agentList:
            if (len(agent.plan) > maxPlanLength):
                maxPlanLength = len(agent.plan)

        intertwinedPlan = []
        for i in range(maxPlanLength):
            for agent in self.agentList:
                if(i < len(agent.plan)):
                    intertwinedPlan.append(agent.plan[i])
        return intertwinedPlan



